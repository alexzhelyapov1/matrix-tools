--- File: pom.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- Наши groupId и artifactId -->
    <groupId>com.azapps</groupId>
    <artifactId>matrix-calculator</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <!-- Версии как у друга -->
        <javafx.version>21.0.2</javafx.version>
        <junit.version>5.10.0</junit.version>
        <!-- Наш главный класс -->
        <javafx.main.class>com.azapps.matrixapp.MainApp</javafx.main.class>
    </properties>

    <dependencies>
        <!-- JavaFX -->
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-controls</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-fxml</artifactId>
            <version>${javafx.version}</version>
        </dependency>

        <!-- JUnit 5 for testing -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Compiler Plugin (версия как у друга) -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                </configuration>
            </plugin>

            <!-- JavaFX Maven Plugin (версия как у друга) -->
            <plugin>
                <groupId>org.openjfx</groupId>
                <artifactId>javafx-maven-plugin</artifactId>
                <version>0.0.8</version>
                <configuration>
                    <mainClass>${javafx.main.class}</mainClass>
                </configuration>
            </plugin>

            <!-- Surefire Plugin for running tests (версия как у друга) -->
            <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
                 <version>3.1.2</version>
            </plugin>
        </plugins>
    </build>
</project>


--- File: src/main/java/com/azapps/matrixapp/model/MatrixOperationException.java ---
package com.azapps.matrixapp.model;

public class MatrixOperationException extends Exception {

    public MatrixOperationException(String message) {
        super(message);
    }

    public MatrixOperationException(String message, Throwable cause) {
        super(message, cause);
    }
}


--- File: src/main/java/com/azapps/matrixapp/model/Matrix.java ---
package com.azapps.matrixapp.model;

import java.util.Arrays;

public class Matrix {
    private final double[][] data;
    private final int rows;
    private final int cols;

    public Matrix(int rows, int cols) {
        if (rows <= 0 || cols <= 0) {
            throw new IllegalArgumentException("Размеры матрицы должны быть положительными.");
        }
        this.rows = rows;
        this.cols = cols;
        this.data = new double[rows][cols];
    }

    public Matrix(double[][] data) {
        if (data == null || data.length == 0 || data[0].length == 0) {
            throw new IllegalArgumentException("Входные данные для матрицы не могут быть пустыми или null.");
        }
        this.rows = data.length;
        this.cols = data[0].length;
        this.data = new double[rows][cols];
        for (int i = 0; i < rows; i++) {
            if (data[i].length != cols) {
                throw new IllegalArgumentException("Все строки матрицы должны иметь одинаковую длину.");
            }
            System.arraycopy(data[i], 0, this.data[i], 0, cols);
        }
    }

    public int getRows() {
        return rows;
    }

    public int getCols() {
        return cols;
    }

    public double getElement(int row, int col) {
        if (row < 0 || row >= rows || col < 0 || col >= cols) {
            throw new IndexOutOfBoundsException("Индекс выходит за пределы матрицы.");
        }
        return data[row][col];
    }

    public void setElement(int row, int col, double value) {
        if (row < 0 || row >= rows || col < 0 || col >= cols) {
            throw new IndexOutOfBoundsException("Индекс выходит за пределы матрицы.");
        }
        data[row][col] = value;
    }

    public double[][] getData() {
        // Возвращаем копию, чтобы предотвратить внешнее изменение внутреннего состояния
        double[][] copy = new double[rows][cols];
        for (int i = 0; i < rows; i++) {
            System.arraycopy(data[i], 0, copy[i], 0, cols);
        }
        return copy;
    }

    // --- Операции над матрицами ---

    /**
     * Транспонирует текущую матрицу.
     * @return Новая матрица, являющаяся транспонированной версией текущей.
     */
    public Matrix transpose() {
        Matrix result = new Matrix(cols, rows);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result.setElement(j, i, this.data[i][j]);
            }
        }
        return result;
    }

    /**
     * Обращает текущую матрицу (если она квадратная и невырожденная).
     * Использует метод Гаусса-Жордана.
     * @return Новая матрица, являющаяся обратной к текущей.
     * @throws MatrixOperationException если матрица не квадратная или вырожденная.
     */
    public Matrix inverse() throws MatrixOperationException {
        if (rows != cols) {
            throw new MatrixOperationException("Матрица должна быть квадратной для нахождения обратной.");
        }

        int n = rows;
        double[][] augmentedMatrix = new double[n][2 * n];

        // Создаем расширенную матрицу [A | I]
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                augmentedMatrix[i][j] = data[i][j];
            }
            augmentedMatrix[i][i + n] = 1; // Единичная матрица справа
        }

        // Прямой ход метода Гаусса (приведение к верхнетреугольному виду)
        for (int i = 0; i < n; i++) {
            // Поиск ведущего элемента (максимального по модулю в текущем столбце) для устойчивости
            int maxRow = i;
            for (int k = i + 1; k < n; k++) {
                if (Math.abs(augmentedMatrix[k][i]) > Math.abs(augmentedMatrix[maxRow][i])) {
                    maxRow = k;
                }
            }

            // Обмен строк, если необходимо
            double[] temp = augmentedMatrix[i];
            augmentedMatrix[i] = augmentedMatrix[maxRow];
            augmentedMatrix[maxRow] = temp;

            // Проверка на вырожденность
            if (Math.abs(augmentedMatrix[i][i]) < 1e-10) { // 1e-10 - малая величина для сравнения с нулем
                throw new MatrixOperationException("Матрица вырождена (определитель равен нулю), обратной матрицы не существует.");
            }

            // Нормализация текущей строки (ведущий элемент равен 1)
            double pivot = augmentedMatrix[i][i];
            for (int j = i; j < 2 * n; j++) {
                augmentedMatrix[i][j] /= pivot;
            }

            // Обнуление элементов под ведущим элементом
            for (int k = 0; k < n; k++) {
                if (k != i) {
                    double factor = augmentedMatrix[k][i];
                    for (int j = i; j < 2 * n; j++) {
                        augmentedMatrix[k][j] -= factor * augmentedMatrix[i][j];
                    }
                }
            }
        }

        // Извлечение обратной матрицы (правая часть расширенной матрицы)
        double[][] inverseData = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                inverseData[i][j] = augmentedMatrix[i][j + n];
            }
        }
        return new Matrix(inverseData);
    }


    /**
     * Вычисляет определитель квадратной матрицы.
     * Использует разложение по первой строке (рекурсивный метод).
     * Может быть неэффективен для больших матриц.
     * Для более эффективного вычисления определителя при обращении лучше использовать информацию,
     * полученную в ходе метода Гаусса.
     * @return Определитель матрицы.
     * @throws MatrixOperationException если матрица не квадратная.
     */
    public double determinant() throws MatrixOperationException {
        if (rows != cols) {
            throw new MatrixOperationException("Определитель можно вычислить только для квадратной матрицы.");
        }
        return calculateDeterminant(this.data);
    }

    private double calculateDeterminant(double[][] matrixData) {
        int n = matrixData.length;
        if (n == 1) {
            return matrixData[0][0];
        }
        if (n == 2) {
            return matrixData[0][0] * matrixData[1][1] - matrixData[0][1] * matrixData[1][0];
        }

        double det = 0;
        for (int j = 0; j < n; j++) {
            det += Math.pow(-1, j) * matrixData[0][j] * calculateDeterminant(getSubmatrix(matrixData, 0, j));
        }
        return det;
    }

    // Вспомогательный метод для получения минора (подматрицы)
    private double[][] getSubmatrix(double[][] matrixData, int excluding_row, int excluding_col) {
        int n = matrixData.length;
        double[][] submatrix = new double[n - 1][n - 1];
        int r = -1;
        for (int i = 0; i < n; i++) {
            if (i == excluding_row) {
                continue;
            }
            r++;
            int c = -1;
            for (int j = 0; j < n; j++) {
                if (j == excluding_col) {
                    continue;
                }
                c++;
                submatrix[r][c] = matrixData[i][j];
            }
        }
        return submatrix;
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < rows; i++) {
            sb.append(Arrays.toString(data[i])).append("\n");
        }
        return sb.toString();
    }
}


--- File: src/main/java/com/azapps/matrixapp/controller/MainViewController.java ---
package com.azapps.matrixapp.controller;

import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.TranslateTransition;
import javafx.fxml.FXML;
import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.Spinner;
import javafx.scene.control.SpinnerValueFactory;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.List;

import com.azapps.matrixapp.model.Matrix;
import com.azapps.matrixapp.model.MatrixOperationException;


public class MainViewController {

    // --- Элементы для ввода матрицы ---
    @FXML private ScrollPane matrixScrollPane;
    @FXML private GridPane matrixInputGrid;

    // --- Элементы для задания размера ---
    @FXML private HBox sizeControlBox; // Контейнер для элементов управления размером
    @FXML private Spinner<Integer> rowsSpinner;
    @FXML private Spinner<Integer> colsSpinner;

    // --- Кнопки операций ---
    // @FXML private AnchorPane buttonsPane; // Больше не нужен AnchorPane как прямой родитель кнопок HBox
    @FXML private HBox buttonsContainer;  // HBox, содержащий кнопки
    @FXML private Button transposeButton;
    @FXML private Button inverseButton;

    // --- Элементы для вывода результата ---
    @FXML private ScrollPane resultScrollPane;
    @FXML private Label resultLabel;

    private List<List<TextField>> matrixTextFields;

    private static final int MAX_DIMENSION = 10;
    private static final int MIN_DIMENSION = 1;
    private static final double BUTTON_SPACING = 10.0; // Расстояние между кнопками в HBox

    @FXML
    public void initialize() {
        System.out.println("MainViewController initialized.");

        setupSpinner(rowsSpinner, 2, MIN_DIMENSION, MAX_DIMENSION);
        setupSpinner(colsSpinner, 2, MIN_DIMENSION, MAX_DIMENSION);

        rowsSpinner.valueProperty().addListener((obs, oldValue, newValue) -> {
            if (newValue != null) updateMatrixGridAndButtons();
        });
        colsSpinner.valueProperty().addListener((obs, oldValue, newValue) -> {
            if (newValue != null) updateMatrixGridAndButtons();
        });
        
        matrixTextFields = new ArrayList<>();

        // Чтобы buttonsContainer был корректно измерен перед первым вызовом updateButtonStates
        buttonsContainer.widthProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal.doubleValue() > 0 && oldVal.doubleValue() == 0) { // Запускаем один раз после инициализации размера
                 updateButtonStates();
            }
        });
        
        updateMatrixGridAndButtons(); // Первоначальное создание и настройка
    }

    private void updateMatrixGridAndButtons() {
        updateMatrixGrid();
        updateButtonStates();
    }

    private void setupSpinner(Spinner<Integer> spinner, int initialValue, int min, int max) {
        SpinnerValueFactory<Integer> valueFactory =
                new SpinnerValueFactory.IntegerSpinnerValueFactory(min, max, initialValue);
        spinner.setValueFactory(valueFactory);
        spinner.getEditor().textProperty().addListener((observable, oldValue, newValue) -> {
            if (!newValue.matches("\\d*")) {
                spinner.getEditor().setText(newValue.replaceAll("[^\\d]", ""));
            }
            if (!newValue.isEmpty()) {
                try {
                    int val = Integer.parseInt(newValue);
                    if (val > max) spinner.getEditor().setText(String.valueOf(max));
                    // Не форсируем min сразу, чтобы пользователь мог ввести, например, "0" для "10"
                } catch (NumberFormatException e) { /* игнор */ }
            }
        });

        spinner.getEditor().focusedProperty().addListener((observable, oldValue, lostFocus) -> {
            if (lostFocus) commitSpinnerValue(spinner);
        });
        spinner.getEditor().setOnAction(event -> commitSpinnerValue(spinner));
    }
    
    private void commitSpinnerValue(Spinner<Integer> spinner) {
        try {
            String text = spinner.getEditor().getText();
            
            // Получаем конкретную фабрику значений
            SpinnerValueFactory.IntegerSpinnerValueFactory valueFactory = null;
            if (spinner.getValueFactory() instanceof SpinnerValueFactory.IntegerSpinnerValueFactory) {
                valueFactory = (SpinnerValueFactory.IntegerSpinnerValueFactory) spinner.getValueFactory();
            } else {
                // Если это не IntegerSpinnerValueFactory, то наша логика min/max не сработает.
                // В этом случае можно просто попытаться установить значение, если оно парсится.
                // Или выбросить ошибку/залогировать.
                // Для нашего приложения мы ожидаем IntegerSpinnerValueFactory.
                if (!text.isEmpty()) spinner.getValueFactory().setValue(Integer.parseInt(text));
                else spinner.getValueFactory().setValue(spinner.getValue()); // Восстановить, если пусто
                return;
            }


            if (text == null || text.isEmpty()) {
                // Если поле пустое, устанавливаем минимальное значение
                spinner.getValueFactory().setValue(valueFactory.getMin()); 
                return;
            }
            
            int value = Integer.parseInt(text);
            
            if (value < valueFactory.getMin()) {
                value = valueFactory.getMin();
            } else if (value > valueFactory.getMax()) {
                value = valueFactory.getMax();
            }
            spinner.getValueFactory().setValue(value);
        } catch (NumberFormatException e) {
            // Если значение невалидно (например, не число), восстанавливаем предыдущее валидное значение
            spinner.getValueFactory().setValue(spinner.getValue());
        } catch (ClassCastException e) {
            // Этого не должно случиться, если мы используем IntegerSpinnerValueFactory,
            // но проверка instanceof выше должна это предотвратить.
            System.err.println("Неожиданная ошибка приведения типа SpinnerValueFactory: " + e.getMessage());
            spinner.getValueFactory().setValue(spinner.getValue()); // Восстановить
        }
    }

    private void updateMatrixGrid() {
        matrixInputGrid.getChildren().clear();
        matrixTextFields.clear();

        int rows = rowsSpinner.getValue();
        int cols = colsSpinner.getValue();

        for (int i = 0; i < rows; i++) {
            List<TextField> rowFields = new ArrayList<>();
            for (int j = 0; j < cols; j++) {
                TextField textField = new TextField();
                textField.setPromptText("0");
                textField.setPrefWidth(60); // Немного увеличим
                textField.setPrefHeight(35); // Явно зададим высоту, можно и через CSS
                textField.setAlignment(Pos.CENTER);
                textField.textProperty().addListener((obs, oldValue, newValue) -> {
                    if (!newValue.matches("-?((\\d*\\.?\\d*)|(\\d+\\.?))")) { // Улучшенная регулярка для чисел
                        textField.setText(oldValue);
                    }
                });
                matrixInputGrid.add(textField, j, i);
                rowFields.add(textField);
            }
            matrixTextFields.add(rowFields);
        }
        resultLabel.setText("");
    }

    private void updateButtonStates() {
        if (buttonsContainer.getWidth() == 0) {
            // Если контейнер еще не отрисован и его ширина 0, откладываем обновление.
            // Это может случиться при первом запуске, слушатель на widthProperty должен это покрыть.
            return;
        }

        int rows = rowsSpinner.getValue();
        int cols = colsSpinner.getValue();
        boolean isSquare = (rows == cols);

        inverseButton.setVisible(isSquare);
        inverseButton.setManaged(isSquare);

        double containerWidth = buttonsContainer.getWidth() - buttonsContainer.getPadding().getLeft() - buttonsContainer.getPadding().getRight();
        double targetButtonWidth;

        if (isSquare) {
            // Обе кнопки видны
            targetButtonWidth = (containerWidth - BUTTON_SPACING) / 2.0;
            transposeButton.setPrefWidth(targetButtonWidth);
            inverseButton.setPrefWidth(targetButtonWidth);
            buttonsContainer.setAlignment(Pos.CENTER_RIGHT); // Выравниваем пару кнопок вправо

            // Убираем смещение для кнопки транспонирования, если оно было
            transposeButton.setTranslateX(0);

        } else {
            // Только кнопка транспонирования видна
            targetButtonWidth = containerWidth; // Занимает всю ширину контейнера (если она одна)
                                                // или можно задать ей чуть меньшую ширину для красоты
            // targetButtonWidth = Math.min(containerWidth, 200); // Например, максимальная ширина для одной кнопки
            transposeButton.setPrefWidth(targetButtonWidth);
            
            // Плавное перемещение кнопки "Транспонировать" в центр buttonsContainer
            // buttonsContainer остается выровненным по правому краю в родительском HBox,
            // а мы двигаем кнопку внутри него.
            // buttonsContainer.setAlignment(Pos.CENTER_LEFT); // Чтобы translateX считался от левого края HBox
            // double buttonCurrentWidth = transposeButton.getBoundsInParent().getWidth(); // Используем актуальную ширину
            // double targetX = (containerWidth / 2.0) - (buttonCurrentWidth / 2.0) - transposeButton.getLayoutX();
            
            // Упрощенный вариант: центрируем HBox, если там только одна кнопка
            buttonsContainer.setAlignment(Pos.CENTER);
            transposeButton.setTranslateX(0); // Убедимся, что нет старого смещения
        }
        
        // Для плавной анимации изменения ширины и положения
        // Анимация ширины (может быть сложной для стандартных кнопок, т.к. prefWidth не анимируется напрямую)
        // Проще анимировать TranslateX
        // Если мы используем buttonsContainer.setAlignment(Pos.CENTER) для одной кнопки,
        // то анимация TranslateX не нужна или должна быть 0.
        // Если же мы хотим, чтобы transposeButton плавно "скользила" в центр контейнера,
        // когда inverseButton исчезает, а сам buttonsContainer не меняет выравнивание,
        // то нужен более сложный расчет TranslateX.

        // Давайте попробуем вариант с изменением выравнивания HBox, это проще и часто выглядит хорошо.
        // Если этого будет недостаточно, реализуем более сложную анимацию TranslateTransition.

        // Повторный вызов для применения ширин перед анимацией (если необходима)
        transposeButton.requestLayout();
        if(isSquare) inverseButton.requestLayout();
    }


    @FXML
    private void handleTransposeAction() {
        System.out.println("Transpose button clicked");
        try {
            double[][] inputData = getMatrixFromInput();
            if (inputData == null) {
                // Ошибка уже отображена в getMatrixFromInput
                return;
            }

            Matrix matrix = new Matrix(inputData);
            Matrix transposedMatrix = matrix.transpose();

            displayMatrixResult(transposedMatrix.getData(), "Транспонированная матрица:");

        } catch (IllegalArgumentException e) { // От конструктора Matrix
            resultLabel.setText("Ошибка создания матрицы: " + e.getMessage());
        } catch (Exception e) { // Общий перехватчик
            resultLabel.setText("Произошла ошибка при транспонировании: " + e.getMessage());
            e.printStackTrace(); // Для отладки в консоль
        }
    }

    @FXML
    private void handleInverseAction() {
        System.out.println("Inverse button clicked");
        try {
            double[][] inputData = getMatrixFromInput();
            if (inputData == null) {
                // Ошибка уже отображена в getMatrixFromInput
                return;
            }

            // Проверка на квадратность здесь уже не так критична, т.к. Matrix.inverse() ее выполнит,
            // но можно оставить для более раннего сообщения пользователю.
            if (rowsSpinner.getValue() != colsSpinner.getValue()) {
                resultLabel.setText("Ошибка: Матрица должна быть квадратной для обращения.");
                return; // Хотя Matrix.inverse() тоже выбросит исключение
            }

            Matrix matrix = new Matrix(inputData);
            Matrix invertedMatrix = matrix.inverse(); // Может выбросить MatrixOperationException

            displayMatrixResult(invertedMatrix.getData(), "Обратная матрица:");

        } catch (IllegalArgumentException e) { // От конструктора Matrix
            resultLabel.setText("Ошибка создания матрицы: " + e.getMessage());
        } catch (MatrixOperationException e) { // От Matrix.inverse()
            resultLabel.setText("Ошибка обращения матрицы: " + e.getMessage());
        } catch (Exception e) { // Общий перехватчик
            resultLabel.setText("Произошла ошибка при обращении: " + e.getMessage());
            e.printStackTrace(); // Для отладки в консоль
        }
    }

    private double[][] getMatrixFromInput() {
        int rows = rowsSpinner.getValue();
        int cols = colsSpinner.getValue();
        double[][] matrix = new double[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                TextField textField = matrixTextFields.get(i).get(j);
                String text = textField.getText().trim();
                if (text.isEmpty() || text.equals("-") || text.equals(".")) {
                    matrix[i][j] = 0.0;
                } else {
                    try {
                        matrix[i][j] = Double.parseDouble(text);
                    } catch (NumberFormatException e) {
                        resultLabel.setText("Ошибка: Некорректное значение в ячейке [" + (i + 1) + "," + (j + 1) + "]: '" + textField.getText() + "'");
                        textField.requestFocus();
                        textField.selectAll();
                        return null;
                    }
                }
            }
        }
        return matrix;
    }

    private void displayMatrixResult(double[][] matrix, String title) {
        StringBuilder sb = new StringBuilder(title + "\n\n");
        for (double[] row : matrix) {
            for (int j = 0; j < row.length; j++) {
                // Используем String.format для контроля количества знаков после запятой
                // и выравнивания. %10.3f означает 10 символов всего, 3 после запятой.
                sb.append(String.format("%10.3f", row[j]));
                if (j < row.length - 1) {
                    sb.append("\t"); // Табуляция между элементами
                }
            }
            sb.append("\n");
        }
        resultLabel.setText(sb.toString());
    }
    
    // --- Заглушки ---
    private double[][] mockTranspose(double[][] matrix) {
        if (matrix == null || matrix.length == 0) return new double[0][0];
        int rows = matrix.length;
        int cols = matrix[0].length;
        double[][] result = new double[cols][rows];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[j][i] = matrix[i][j];
            }
        }
        return result;
    }

    private double[][] mockInverse(double[][] matrix) {
        if (matrix == null || matrix.length == 0) return new double[0][0];
        int n = matrix.length;
        if (n != matrix[0].length) throw new IllegalArgumentException("Матрица не квадратная для обращения.");

        if (n == 1) {
            if (Math.abs(matrix[0][0]) < 1e-9) throw new ArithmeticException("Определитель равен нулю (1x1).");
            return new double[][]{{1.0 / matrix[0][0]}};
        }
        if (n == 2) {
            double a = matrix[0][0], b = matrix[0][1], c = matrix[1][0], d = matrix[1][1];
            double det = a * d - b * c;
            if (Math.abs(det) < 1e-9) throw new ArithmeticException("Матрица вырождена (определитель равен нулю).");
            return new double[][]{{d / det, -b / det}, {-c / det, a / det}};
        }
        throw new UnsupportedOperationException("Обращение для матриц размером больше 2х2 пока не реализовано (заглушка).");
    }
}


--- File: src/main/java/com/azapps/matrixapp/MainApp.java ---
package com.azapps.matrixapp;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.io.IOException;
import java.net.URL;
import java.util.Objects;

public class MainApp extends Application {

    @Override
    public void start(Stage primaryStage) {
        try {
            // Загружаем FXML файл из папки resources/com/azapps/matrixapp/view/
            // Обратите внимание на путь к FXML файлу.
            // getClass().getResource() ищет ресурс относительно расположения класса MainApp.
            // "/com/azapps/matrixapp/view/MainView.fxml" - абсолютный путь от корня classpath.
            // Если FXML лежит в той же папке, что и MainApp (или в подпапке view относительно MainApp),
            // можно использовать относительный путь: "view/MainView.fxml"
            URL fxmlLocation = getClass().getResource("/com/azapps/matrixapp/view/MainView.fxml");
            if (fxmlLocation == null) {
                System.err.println("Не удалось найти FXML файл. Проверьте путь: /com/azapps/matrixapp/view/MainView.fxml");
                // Можно выбросить исключение или показать диалоговое окно с ошибкой
                return;
            }
            Parent root = FXMLLoader.load(Objects.requireNonNull(fxmlLocation));

            // Устанавливаем заголовок окна
            primaryStage.setTitle("Калькулятор Матриц");

            // Создаем сцену
            Scene scene = new Scene(root, 800, 600); // Начальные размеры окна

            // Устанавливаем сцену для Stage
            primaryStage.setScene(scene);

            // Отображаем Stage (окно)
            primaryStage.show();

        } catch (IOException e) {
            // Обработка исключения, если FXML файл не может быть загружен
            e.printStackTrace();
            // Здесь можно показать пользователю сообщение об ошибке
            // например, через Alert
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}


--- File: src/main/java/module-info.java ---
module com.azapps.matrixapp {
    // Зависимости от модулей JavaFX
    requires javafx.controls;
    requires javafx.fxml;
    requires javafx.graphics; // Явно добавим зависимость от javafx.graphics, так как он упоминается в ошибке

    // Открываем наши пакеты для JavaFX FXML
    opens com.azapps.matrixapp to javafx.fxml;
    opens com.azapps.matrixapp.controller to javafx.fxml;
    // Если FXML будет напрямую ссылаться на классы модели,
    // то и пакет модели нужно будет открыть:
    // opens com.azapps.matrixapp.model to javafx.fxml;

    // ЭКСПОРТИРУЕМ пакет, содержащий MainApp
    exports com.azapps.matrixapp; // Эта строка необходима
    // Если другие модули (кроме javafx.graphics) должны использовать ваши контроллеры или модели,
    // их тоже можно экспортировать, но для текущей ошибки важен именно пакет с MainApp.
    // exports com.azapps.matrixapp.controller;
    // exports com.azapps.matrixapp.model;
}


--- File: src/main/resources/com/azapps/matrixapp/view/MainView.fxml ---
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.control.Spinner?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.Priority?>
<?import javafx.scene.layout.Region?>
<?import javafx.scene.layout.VBox?>

<BorderPane xmlns="http://javafx.com/javafx/21"
            xmlns:fx="http://javafx.com/fxml/1"
            fx:controller="com.azapps.matrixapp.controller.MainViewController"
            prefHeight="700.0" prefWidth="900.0"
            stylesheets="@../css/styles.css"> <!-- Подключаем CSS файл -->

    <top>
        <VBox alignment="CENTER" spacing="10" styleClass="header-box"> <!-- Используем styleClass -->
            <Label text="Калькулятор Матриц" styleClass="header-label"/> <!-- Используем styleClass -->
        </VBox>
    </top>

    <center>
        <VBox spacing="15" alignment="TOP_CENTER">
            <padding>
                <Insets top="20" right="20" bottom="20" left="20"/>
            </padding>

            <Label text="Введите элементы матрицы:" styleClass="section-label"/>

            <ScrollPane fx:id="matrixScrollPane" fitToWidth="true" fitToHeight="true" VBox.vgrow="ALWAYS"
                        minHeight="200" prefHeight="300">
                <content>
                    <GridPane fx:id="matrixInputGrid" hgap="5" vgap="5" alignment="CENTER">
                        <padding>
                            <Insets top="10" right="10" bottom="10" left="10"/>
                        </padding>
                    </GridPane>
                </content>
            </ScrollPane>

            <!-- Панель управления: размеры и кнопки -->
            <HBox spacing="20" alignment="CENTER_LEFT">
                <padding>
                    <Insets top="10"/>
                </padding>

                <!-- Секция задания размера (фиксированная ширина) -->
                <HBox fx:id="sizeControlBox" spacing="5" alignment="CENTER_LEFT" prefWidth="250" minWidth="250" maxWidth="250">
                    <Label text="Размер матрицы:" styleClass="control-label"/>
                    <Spinner fx:id="rowsSpinner" editable="true" min="1" max="10" initialValue="2" prefWidth="70"/>
                    <Label text="x" styleClass="control-label-small"/>
                    <Spinner fx:id="colsSpinner" editable="true" min="1" max="10" initialValue="2" prefWidth="70"/>
                </HBox>

                <!-- Распорка, чтобы кнопки были справа -->
                <Region HBox.hgrow="ALWAYS"/>

                <!-- Контейнер для кнопок (фиксированная ширина справа) -->
                <HBox fx:id="buttonsContainer" spacing="10" alignment="CENTER_RIGHT"
                      prefWidth="350" minWidth="350" maxWidth="350">
                    <!-- Кнопки будут иметь одинаковую предпочтительную ширину и расти, если нужно -->
                    <Button fx:id="transposeButton" text="Транспонировать" onAction="#handleTransposeAction"
                            prefHeight="40" styleClass="action-button"/>
                    <Button fx:id="inverseButton" text="Обратить" onAction="#handleInverseAction"
                            prefHeight="40" styleClass="action-button"/>
                </HBox>
            </HBox>

            <Label text="Результат:" styleClass="section-label" style="-fx-padding: 10 0 0 0;"/>
            <ScrollPane fx:id="resultScrollPane" fitToWidth="true" fitToHeight="true" VBox.vgrow="ALWAYS"
                        minHeight="100" prefHeight="200">
                <content>
                    <Label fx:id="resultLabel" text="" wrapText="true" styleClass="result-text"/>
                </content>
            </ScrollPane>

        </VBox>
    </center>
</BorderPane>


--- File: src/main/resources/com/azapps/matrixapp/css/styles.css ---
/* styles.css */

.root {
    -fx-font-family: "System"; /* Или другой предпочитаемый шрифт */
    -fx-font-size: 14px;
}

.header-box {
    -fx-background-color: #4A90E2; /* Приятный синий цвет */
    -fx-padding: 15px;
}

.header-label {
    -fx-font-size: 24px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.section-label {
    -fx-font-size: 16px;
    -fx-font-weight: bold;
    -fx-text-fill: #333333;
}

.control-label {
    -fx-font-size: 14px;
    -fx-text-fill: #444444;
}
.control-label-small {
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-text-fill: #444444;
}

.spinner .arrow-button {
    -fx-padding: 2 5 2 5; /* Уменьшаем отступы кнопок спиннера */
}

.spinner .text-field {
     -fx-pref-height: 30px; /* Высота текстового поля спиннера */
}


.action-button {
    -fx-background-color: #5CB85C; /* Зеленый */
    -fx-text-fill: white;
    -fx-font-weight: bold;
    -fx-font-size: 14px;
    -fx-background-radius: 5px; /* Скругленные углы */
    -fx-padding: 10px 15px; /* Отступы внутри кнопки */
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.1), 5, 0, 2, 2); /* Легкая тень */
}

.action-button:hover {
    -fx-background-color: #4CAF50; /* Темнее при наведении */
}

.action-button:pressed {
    -fx-background-color: #45A049; /* Еще темнее при нажатии */
}

/* Можно добавить стиль для кнопки "Обратить", если хотите другой цвет */
#inverseButton.action-button { /* ID selector для специфичной кнопки */
    -fx-background-color: #F0AD4E; /* Оранжевый */
}
#inverseButton.action-button:hover {
    -fx-background-color: #EEA236;
}
#inverseButton.action-button:pressed {
    -fx-background-color: #EC9B2F;
}


.text-field { /* Стиль для обычных текстовых полей в гриде */
    -fx-pref-height: 35px;
    -fx-border-color: #cccccc;
    -fx-border-radius: 3px;
}

.text-field:focused {
    -fx-border-color: #4A90E2;
    -fx-effect: dropshadow(gaussian, #4A90E2, 5, 0.1, 0, 0);
}


.result-text {
    -fx-font-family: "Courier New", monospace;
    -fx-font-size: 14px;
    -fx-fill: #333333;
    -fx-background-color: #f9f9f9;
    -fx-border-color: #e0e0e0;
    -fx-padding: 10px;
}

.scroll-pane {
    -fx-background-color: transparent; /* Чтобы не было двойных рамок */
}

.scroll-pane .viewport {
    -fx-background-color: transparent;
}


