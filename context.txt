--- File: pom.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- Наши groupId и artifactId -->
    <groupId>com.azapps</groupId>
    <artifactId>matrix-calculator</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <!-- Версии как у друга -->
        <javafx.version>21.0.2</javafx.version>
        <junit.version>5.10.0</junit.version>
        <!-- Наш главный класс -->
        <javafx.main.class>com.azapps.matrixapp.MainApp</javafx.main.class>
    </properties>

    <dependencies>
        <!-- JavaFX -->
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-controls</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-fxml</artifactId>
            <version>${javafx.version}</version>
        </dependency>

        <!-- JUnit 5 for testing -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Compiler Plugin (версия как у друга) -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                </configuration>
            </plugin>

            <!-- JavaFX Maven Plugin (версия как у друга) -->
            <plugin>
                <groupId>org.openjfx</groupId>
                <artifactId>javafx-maven-plugin</artifactId>
                <version>0.0.8</version>
                <configuration>
                    <mainClass>${javafx.main.class}</mainClass>
                </configuration>
            </plugin>

            <!-- Surefire Plugin for running tests (версия как у друга) -->
            <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
                 <version>3.1.2</version>
            </plugin>
        </plugins>
    </build>
</project>


--- File: src/test/java/com/azapps/matrixapp/model/MatrixTest.java ---
package com.azapps.matrixapp.model;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import java.util.Arrays;

public class MatrixTest {

    private static final double DELTA = 1e-9; // Для сравнения double

    // --- Тесты конструкторов ---
    @Test
    void constructor_validDimensions_createsMatrix() {
        Matrix matrix = new Matrix(2, 3);
        assertEquals(2, matrix.getRows());
        assertEquals(3, matrix.getCols());
        // Проверим, что элементы по умолчанию 0.0
        for (int i = 0; i < matrix.getRows(); i++) {
            for (int j = 0; j < matrix.getCols(); j++) {
                assertEquals(0.0, matrix.getElement(i, j), DELTA);
            }
        }
    }

    @Test
    void constructor_fromValidData_createsMatrix() {
        double[][] data = {{1, 2}, {3, 4}};
        Matrix matrix = new Matrix(data);
        assertEquals(2, matrix.getRows());
        assertEquals(2, matrix.getCols());
        assertArrayEquals(data[0], matrix.getData()[0], DELTA);
        assertArrayEquals(data[1], matrix.getData()[1], DELTA);
    }

    @Test
    void constructor_zeroRows_throwsIllegalArgumentException() {
        assertThrows(IllegalArgumentException.class, () -> new Matrix(0, 3));
    }

    @Test
    void constructor_zeroCols_throwsIllegalArgumentException() {
        assertThrows(IllegalArgumentException.class, () -> new Matrix(2, 0));
    }

    @Test
    void constructor_fromNullData_throwsIllegalArgumentException() {
        assertThrows(IllegalArgumentException.class, () -> new Matrix(null));
    }

    @Test
    void constructor_fromEmptyData_throwsIllegalArgumentException() {
        double[][] emptyData = {};
        assertThrows(IllegalArgumentException.class, () -> new Matrix(emptyData));
        double[][] emptyRowData = {{}};
        assertThrows(IllegalArgumentException.class, () -> new Matrix(emptyRowData)); // Если строки нулевой длины
    }

    @Test
    void constructor_fromJaggedArray_throwsIllegalArgumentException() {
        double[][] jaggedData = {{1, 2}, {3}};
        assertThrows(IllegalArgumentException.class, () -> new Matrix(jaggedData));
    }

    // --- Тесты геттеров/сеттеров ---
    @Test
    void getElement_validIndices_returnsElement() {
        double[][] data = {{1, 2}, {3, 4}};
        Matrix matrix = new Matrix(data);
        assertEquals(3, matrix.getElement(1, 0), DELTA);
    }

    @Test
    void getElement_invalidRow_throwsIndexOutOfBoundsException() {
        Matrix matrix = new Matrix(2, 2);
        assertThrows(IndexOutOfBoundsException.class, () -> matrix.getElement(2, 0));
    }

    @Test
    void setElement_validIndices_setsElement() {
        Matrix matrix = new Matrix(2, 2);
        matrix.setElement(0, 1, 5.5);
        assertEquals(5.5, matrix.getElement(0, 1), DELTA);
    }

    @Test
    void getData_returnsCopyNotReference() {
        double[][] initialData = {{1, 2}, {3, 4}};
        Matrix matrix = new Matrix(initialData);
        double[][] retrievedData = matrix.getData();

        // Изменяем полученный массив
        retrievedData[0][0] = 99;

        // Проверяем, что исходная матрица не изменилась
        assertEquals(1, matrix.getElement(0, 0), DELTA, "Изменение копии не должно влиять на оригинал");
    }


    // --- Тесты транспонирования ---
    @Test
    void transpose_squareMatrix() {
        double[][] data = {{1, 2}, {3, 4}};
        Matrix matrix = new Matrix(data);
        Matrix transposed = matrix.transpose();
        double[][] expected = {{1, 3}, {2, 4}};
        assertArrayEquals(expected[0], transposed.getData()[0], DELTA);
        assertArrayEquals(expected[1], transposed.getData()[1], DELTA);
        assertEquals(2, transposed.getRows());
        assertEquals(2, transposed.getCols());
    }

    @Test
    void transpose_rectangularMatrix_2x3() {
        double[][] data = {{1, 2, 3}, {4, 5, 6}};
        Matrix matrix = new Matrix(data);
        Matrix transposed = matrix.transpose();
        double[][] expected = {{1, 4}, {2, 5}, {3, 6}};
        assertEquals(3, transposed.getRows());
        assertEquals(2, transposed.getCols());
        for (int i = 0; i < expected.length; i++) {
            assertArrayEquals(expected[i], transposed.getData()[i], DELTA);
        }
    }
    
    @Test
    void transpose_matrix1x1() {
        double[][] data = {{5}};
        Matrix matrix = new Matrix(data);
        Matrix transposed = matrix.transpose();
        double[][] expected = {{5}};
        assertArrayEquals(expected[0], transposed.getData()[0], DELTA);
        assertEquals(1, transposed.getRows());
        assertEquals(1, transposed.getCols());
    }

    // --- Тесты обращения ---
    @Test
    void inverse_2x2_nonSingularMatrix() throws MatrixOperationException {
        double[][] data = {{1, 2}, {3, 4}}; // det = -2
        Matrix matrix = new Matrix(data);
        Matrix inverted = matrix.inverse();
        double[][] expected = {{-2, 1}, {1.5, -0.5}};
        for (int i = 0; i < expected.length; i++) {
            assertArrayEquals(expected[i], inverted.getData()[i], DELTA);
        }
    }

    @Test
    void inverse_3x3_nonSingularMatrix() throws MatrixOperationException {
        double[][] data = {{2, -1, 0}, {-1, 2, -1}, {0, -1, 2}}; // det = 4
        Matrix matrix = new Matrix(data);
        Matrix inverted = matrix.inverse();
        double[][] expected = {{0.75, 0.5, 0.25}, {0.5, 1.0, 0.5}, {0.25, 0.5, 0.75}};
        for (int i = 0; i < expected.length; i++) {
            assertArrayEquals(expected[i], inverted.getData()[i], DELTA);
        }
    }

    @Test
    void inverse_identityMatrix() throws MatrixOperationException {
        double[][] data = {{1, 0}, {0, 1}};
        Matrix matrix = new Matrix(data);
        Matrix inverted = matrix.inverse();
        double[][] expected = {{1, 0}, {0, 1}};
        for (int i = 0; i < expected.length; i++) {
            assertArrayEquals(expected[i], inverted.getData()[i], DELTA);
        }
    }
    
    @Test
    void inverse_matrix1x1_nonZero() throws MatrixOperationException {
        double[][] data = {{5}};
        Matrix matrix = new Matrix(data);
        Matrix inverted = matrix.inverse();
        double[][] expected = {{0.2}};
        assertArrayEquals(expected[0], inverted.getData()[0], DELTA);
    }

    @Test
    void inverse_matrix1x1_zero_throwsException() {
        double[][] data = {{0}};
        Matrix matrix = new Matrix(data);
        assertThrows(MatrixOperationException.class, matrix::inverse, "Должно быть выброшено исключение для вырожденной матрицы 1x1");
    }

    @Test
    void inverse_nonSquareMatrix_throwsMatrixOperationException() {
        double[][] data = {{1, 2, 3}, {4, 5, 6}};
        Matrix matrix = new Matrix(data);
        assertThrows(MatrixOperationException.class, matrix::inverse);
    }

    @Test
    void inverse_singularMatrix_throwsMatrixOperationException() {
        double[][] data = {{1, 2}, {2, 4}}; // det = 0
        Matrix matrix = new Matrix(data);
        assertThrows(MatrixOperationException.class, matrix::inverse);
    }
    
    // --- Тесты определителя (опционально, если он важен сам по себе) ---
    @Test
    void determinant_2x2_nonSingular() throws MatrixOperationException {
        double[][] data = {{1, 2}, {3, 4}};
        Matrix matrix = new Matrix(data);
        assertEquals(-2.0, matrix.determinant(), DELTA);
    }

    @Test
    void determinant_3x3_nonSingular() throws MatrixOperationException {
        double[][] data = {{2, -1, 0}, {-1, 2, -1}, {0, -1, 2}};
        Matrix matrix = new Matrix(data);
        assertEquals(4.0, matrix.determinant(), DELTA);
    }

    @Test
    void determinant_singularMatrix_isZero() throws MatrixOperationException {
        double[][] data = {{1, 2}, {2, 4}};
        Matrix matrix = new Matrix(data);
        assertEquals(0.0, matrix.determinant(), DELTA);
    }

    @Test
    void determinant_nonSquareMatrix_throwsMatrixOperationException() {
        double[][] data = {{1, 2, 3}, {4, 5, 6}};
        Matrix matrix = new Matrix(data);
        assertThrows(MatrixOperationException.class, matrix::determinant);
    }
}


--- File: src/main/java/com/azapps/matrixapp/model/MatrixOperationException.java ---
package com.azapps.matrixapp.model;

public class MatrixOperationException extends Exception {

    public MatrixOperationException(String message) {
        super(message);
    }

    public MatrixOperationException(String message, Throwable cause) {
        super(message, cause);
    }
}


--- File: src/main/java/com/azapps/matrixapp/model/Matrix.java ---
package com.azapps.matrixapp.model;

import java.util.Arrays;

public class Matrix {
    private final double[][] data;
    private final int rows;
    private final int cols;

    public Matrix(int rows, int cols) {
        if (rows <= 0 || cols <= 0) {
            throw new IllegalArgumentException("Размеры матрицы должны быть положительными.");
        }
        this.rows = rows;
        this.cols = cols;
        this.data = new double[rows][cols];
    }

    public Matrix(double[][] data) {
        if (data == null || data.length == 0 || data[0].length == 0) {
            throw new IllegalArgumentException("Входные данные для матрицы не могут быть пустыми или null.");
        }
        this.rows = data.length;
        this.cols = data[0].length;
        this.data = new double[rows][cols];
        for (int i = 0; i < rows; i++) {
            if (data[i].length != cols) {
                throw new IllegalArgumentException("Все строки матрицы должны иметь одинаковую длину.");
            }
            System.arraycopy(data[i], 0, this.data[i], 0, cols);
        }
    }

    public int getRows() {
        return rows;
    }

    public int getCols() {
        return cols;
    }

    public double getElement(int row, int col) {
        if (row < 0 || row >= rows || col < 0 || col >= cols) {
            throw new IndexOutOfBoundsException("Индекс выходит за пределы матрицы.");
        }
        return data[row][col];
    }

    public void setElement(int row, int col, double value) {
        if (row < 0 || row >= rows || col < 0 || col >= cols) {
            throw new IndexOutOfBoundsException("Индекс выходит за пределы матрицы.");
        }
        data[row][col] = value;
    }

    public double[][] getData() {
        // Возвращаем копию, чтобы предотвратить внешнее изменение внутреннего состояния
        double[][] copy = new double[rows][cols];
        for (int i = 0; i < rows; i++) {
            System.arraycopy(data[i], 0, copy[i], 0, cols);
        }
        return copy;
    }

    // --- Операции над матрицами ---

    /**
     * Транспонирует текущую матрицу.
     * @return Новая матрица, являющаяся транспонированной версией текущей.
     */
    public Matrix transpose() {
        Matrix result = new Matrix(cols, rows);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result.setElement(j, i, this.data[i][j]);
            }
        }
        return result;
    }

    /**
     * Обращает текущую матрицу (если она квадратная и невырожденная).
     * Использует метод Гаусса-Жордана.
     * @return Новая матрица, являющаяся обратной к текущей.
     * @throws MatrixOperationException если матрица не квадратная или вырожденная.
     */
    public Matrix inverse() throws MatrixOperationException {
        if (rows != cols) {
            throw new MatrixOperationException("Матрица должна быть квадратной для нахождения обратной.");
        }

        int n = rows;
        double[][] augmentedMatrix = new double[n][2 * n];

        // Создаем расширенную матрицу [A | I]
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                augmentedMatrix[i][j] = data[i][j];
            }
            augmentedMatrix[i][i + n] = 1; // Единичная матрица справа
        }

        // Прямой ход метода Гаусса (приведение к верхнетреугольному виду)
        for (int i = 0; i < n; i++) {
            // Поиск ведущего элемента (максимального по модулю в текущем столбце) для устойчивости
            int maxRow = i;
            for (int k = i + 1; k < n; k++) {
                if (Math.abs(augmentedMatrix[k][i]) > Math.abs(augmentedMatrix[maxRow][i])) {
                    maxRow = k;
                }
            }

            // Обмен строк, если необходимо
            double[] temp = augmentedMatrix[i];
            augmentedMatrix[i] = augmentedMatrix[maxRow];
            augmentedMatrix[maxRow] = temp;

            // Проверка на вырожденность
            if (Math.abs(augmentedMatrix[i][i]) < 1e-10) { // 1e-10 - малая величина для сравнения с нулем
                throw new MatrixOperationException("Матрица вырождена (определитель равен нулю), обратной матрицы не существует.");
            }

            // Нормализация текущей строки (ведущий элемент равен 1)
            double pivot = augmentedMatrix[i][i];
            for (int j = i; j < 2 * n; j++) {
                augmentedMatrix[i][j] /= pivot;
            }

            // Обнуление элементов под ведущим элементом
            for (int k = 0; k < n; k++) {
                if (k != i) {
                    double factor = augmentedMatrix[k][i];
                    for (int j = i; j < 2 * n; j++) {
                        augmentedMatrix[k][j] -= factor * augmentedMatrix[i][j];
                    }
                }
            }
        }

        // Извлечение обратной матрицы (правая часть расширенной матрицы)
        double[][] inverseData = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                inverseData[i][j] = augmentedMatrix[i][j + n];
            }
        }
        return new Matrix(inverseData);
    }


    /**
     * Вычисляет определитель квадратной матрицы.
     * Использует разложение по первой строке (рекурсивный метод).
     * Может быть неэффективен для больших матриц.
     * Для более эффективного вычисления определителя при обращении лучше использовать информацию,
     * полученную в ходе метода Гаусса.
     * @return Определитель матрицы.
     * @throws MatrixOperationException если матрица не квадратная.
     */
    public double determinant() throws MatrixOperationException {
        if (rows != cols) {
            throw new MatrixOperationException("Определитель можно вычислить только для квадратной матрицы.");
        }
        return calculateDeterminant(this.data);
    }

    private double calculateDeterminant(double[][] matrixData) {
        int n = matrixData.length;
        if (n == 1) {
            return matrixData[0][0];
        }
        if (n == 2) {
            return matrixData[0][0] * matrixData[1][1] - matrixData[0][1] * matrixData[1][0];
        }

        double det = 0;
        for (int j = 0; j < n; j++) {
            det += Math.pow(-1, j) * matrixData[0][j] * calculateDeterminant(getSubmatrix(matrixData, 0, j));
        }
        return det;
    }

    // Вспомогательный метод для получения минора (подматрицы)
    private double[][] getSubmatrix(double[][] matrixData, int excluding_row, int excluding_col) {
        int n = matrixData.length;
        double[][] submatrix = new double[n - 1][n - 1];
        int r = -1;
        for (int i = 0; i < n; i++) {
            if (i == excluding_row) {
                continue;
            }
            r++;
            int c = -1;
            for (int j = 0; j < n; j++) {
                if (j == excluding_col) {
                    continue;
                }
                c++;
                submatrix[r][c] = matrixData[i][j];
            }
        }
        return submatrix;
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < rows; i++) {
            sb.append(Arrays.toString(data[i])).append("\n");
        }
        return sb.toString();
    }
}


--- File: src/main/java/com/azapps/matrixapp/controller/MainViewController.java ---
package com.azapps.matrixapp.controller;

import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.TranslateTransition;
import javafx.application.Platform;
import javafx.fxml.FXML;
import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.Spinner;
import javafx.scene.control.SpinnerValueFactory;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority; // Для HBox.setHgrow
import javafx.scene.layout.Region;   // Для Region
import javafx.util.Duration;
import javafx.scene.Node;

import java.util.ArrayList;
import java.util.List;

import com.azapps.matrixapp.model.Matrix;
import com.azapps.matrixapp.model.MatrixOperationException;


public class MainViewController {

    // --- Элементы для ввода матрицы ---
    @FXML private ScrollPane matrixScrollPane;
    @FXML private GridPane matrixInputGrid;

    // --- Элементы для задания размера ---
    @FXML private HBox sizeControlBox; // Контейнер для элементов управления размером
    @FXML private Spinner<Integer> rowsSpinner;
    @FXML private Spinner<Integer> colsSpinner;

    // --- Кнопки операций ---
    // @FXML private AnchorPane buttonsPane; // Больше не нужен AnchorPane как прямой родитель кнопок HBox
    @FXML private HBox buttonsContainer;
    @FXML private Button transposeButton;
    @FXML private Button inverseButton;

    private TranslateTransition transposeButtonAnimator; // Аниматор для кнопки

    // --- Элементы для вывода результата ---
    @FXML private ScrollPane resultMatrixScrollPane; // Новая ссылка на ScrollPane для результата
    @FXML private GridPane resultMatrixGrid;        // Новая ссылка на GridPane для результата

    private List<List<TextField>> matrixTextFields;

    private static final int MAX_DIMENSION = 10;
    private static final int MIN_DIMENSION = 1;
    private static final double BUTTON_SPACING = 10.0; // Расстояние между кнопками в HBox

    @FXML
    public void initialize() {
        System.out.println("MainViewController initialized.");

        setupSpinner(rowsSpinner, 2, MIN_DIMENSION, MAX_DIMENSION);
        setupSpinner(colsSpinner, 2, MIN_DIMENSION, MAX_DIMENSION);

        rowsSpinner.valueProperty().addListener((obs, oldValue, newValue) -> {
            if (newValue != null) updateMatrixGridAndButtons();
        });
        colsSpinner.valueProperty().addListener((obs, oldValue, newValue) -> {
            if (newValue != null) updateMatrixGridAndButtons();
        });
        
        matrixTextFields = new ArrayList<>();
        transposeButtonAnimator = new TranslateTransition(Duration.millis(300), transposeButton);
        transposeButtonAnimator.setInterpolator(Interpolator.EASE_BOTH);

        Platform.runLater(this::updateMatrixGridAndButtons);
    }

    private void updateMatrixGridAndButtons() {
        updateMatrixGrid();
        Platform.runLater(this::updateButtonStates);
    }

    private void setupSpinner(Spinner<Integer> spinner, int initialValue, int min, int max) {
        SpinnerValueFactory<Integer> valueFactory =
                new SpinnerValueFactory.IntegerSpinnerValueFactory(min, max, initialValue);
        spinner.setValueFactory(valueFactory);
        spinner.getEditor().textProperty().addListener((observable, oldValue, newValue) -> {
            if (!newValue.matches("\\d*")) {
                spinner.getEditor().setText(newValue.replaceAll("[^\\d]", ""));
            }
            if (!newValue.isEmpty()) {
                try {
                    int val = Integer.parseInt(newValue);
                    if (val > max) spinner.getEditor().setText(String.valueOf(max));
                } catch (NumberFormatException e) { /* игнор */ }
            }
        });
        spinner.getEditor().focusedProperty().addListener((observable, oldValue, lostFocus) -> {
            if (lostFocus) commitSpinnerValue(spinner);
        });
        spinner.getEditor().setOnAction(event -> commitSpinnerValue(spinner));
    }
    
    private void commitSpinnerValue(Spinner<Integer> spinner) {
        try {
            String text = spinner.getEditor().getText();
            SpinnerValueFactory.IntegerSpinnerValueFactory valueFactory = null;
            if (spinner.getValueFactory() instanceof SpinnerValueFactory.IntegerSpinnerValueFactory) {
                valueFactory = (SpinnerValueFactory.IntegerSpinnerValueFactory) spinner.getValueFactory();
            } else {
                if (!text.isEmpty()) spinner.getValueFactory().setValue(Integer.parseInt(text));
                else spinner.getValueFactory().setValue(spinner.getValue());
                return;
            }

            if (text == null || text.isEmpty()) {
                spinner.getValueFactory().setValue(valueFactory.getMin()); 
                return;
            }
            
            int value = Integer.parseInt(text);
            
            if (value < valueFactory.getMin()) value = valueFactory.getMin();
            else if (value > valueFactory.getMax()) value = valueFactory.getMax();
            spinner.getValueFactory().setValue(value);
        } catch (NumberFormatException e) {
            spinner.getValueFactory().setValue(spinner.getValue());
        } catch (ClassCastException e) {
            System.err.println("Неожиданная ошибка приведения типа SpinnerValueFactory: " + e.getMessage());
            spinner.getValueFactory().setValue(spinner.getValue());
        }
    }

    private void updateMatrixGrid() {
        matrixInputGrid.getChildren().clear();
        if (matrixTextFields != null) matrixTextFields.clear();
        else matrixTextFields = new ArrayList<>();

        int currentRows = rowsSpinner.getValue();
        int currentCols = colsSpinner.getValue();

        for (int i = 0; i < currentRows; i++) {
            List<TextField> rowFields = new ArrayList<>();
            for (int j = 0; j < currentCols; j++) {
                TextField textField = new TextField();
                textField.setPromptText("0");
                textField.setPrefWidth(60);
                textField.setPrefHeight(35);
                textField.setAlignment(Pos.CENTER);
                textField.textProperty().addListener((obs, oldValue, newValue) -> {
                    if (!newValue.matches("-?((\\d*\\.?\\d*)|(\\d+\\.?))")) {
                        textField.setText(oldValue);
                    }
                });
                matrixInputGrid.add(textField, j, i);
                rowFields.add(textField);
            }
            matrixTextFields.add(rowFields);
        }
        initializeOrUpdateResultMatrixGrid(currentRows, currentCols);
    }

    private void initializeOrUpdateResultMatrixGrid(int rows, int cols) {
        if (resultMatrixGrid == null) return;
        resultMatrixGrid.getChildren().clear();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                TextField resultField = new TextField();
                resultField.setPromptText("-"); 
                resultField.setEditable(false);
                resultField.setFocusTraversable(false);
                resultField.getStyleClass().add("result-matrix-cell");
                resultField.setPrefWidth(60); 
                resultField.setPrefHeight(35);
                resultField.setAlignment(Pos.CENTER);
                resultMatrixGrid.add(resultField, j, i);
            }
        }
    }

    // Метод clearResultMatrixGrid() был удален, т.к. его функциональность
    // покрывается getChildren().clear() в других методах.

    private void updateButtonStates() {
        if (buttonsContainer.getWidth() == 0 && buttonsContainer.isVisible()) { 
            // Добавил isVisible(), чтобы не пытаться обновить, если контейнер скрыт при инициализации
            Platform.runLater(this::updateButtonStates); // Попробовать обновить позже, если ширина 0
            return;
        }
        if (buttonsContainer.getWidth() == 0 && !buttonsContainer.isVisible()) {
            return; // Если невидимый и ширина 0, ничего не делаем
        }


        final int rows = rowsSpinner.getValue();
        final int cols = colsSpinner.getValue();
        final boolean isSquare = (rows == cols);

        if (!isSquare) {
            inverseButton.setVisible(false);
            inverseButton.setManaged(false);
        }

        HBox.setHgrow(transposeButton, Priority.NEVER);
        HBox.setHgrow(inverseButton, Priority.NEVER);
        
        final double containerWidth = buttonsContainer.getWidth() - buttonsContainer.getPadding().getLeft() - buttonsContainer.getPadding().getRight();
        
        if (isSquare) {
            final double availableWidthForTwoButtons = containerWidth - BUTTON_SPACING;
            final double buttonWidth = Math.max(50, availableWidthForTwoButtons / 2.0);
            transposeButton.setPrefWidth(buttonWidth);
            
            transposeButtonAnimator.setOnFinished(null);

            if (transposeButton.getTranslateX() != 0 || buttonsContainer.getAlignment() == Pos.CENTER_LEFT) {
                buttonsContainer.setAlignment(Pos.CENTER_LEFT);
                transposeButtonAnimator.setToX(0);
                transposeButtonAnimator.setOnFinished(event -> {
                    buttonsContainer.setAlignment(Pos.CENTER_RIGHT);
                    inverseButton.setPrefWidth(buttonWidth);
                    inverseButton.setVisible(true);
                    inverseButton.setManaged(true);
                    buttonsContainer.requestLayout(); 
                    transposeButton.requestLayout();
                    inverseButton.requestLayout();
                    transposeButtonAnimator.setOnFinished(null);
                });
                transposeButtonAnimator.play();
            } else {
                buttonsContainer.setAlignment(Pos.CENTER_RIGHT);
                // transposeButton.setTranslateX(0); // Уже 0, если сюда попали
                inverseButton.setPrefWidth(buttonWidth);
                inverseButton.setVisible(true);
                inverseButton.setManaged(true);
                buttonsContainer.requestLayout();
                transposeButton.requestLayout();
                inverseButton.requestLayout();
            }
        } else {
            double singleButtonPrefWidth = Math.max(150, (containerWidth - BUTTON_SPACING) / 2.0);
            transposeButton.setPrefWidth(singleButtonPrefWidth);
            buttonsContainer.setAlignment(Pos.CENTER_LEFT);
            
            double buttonActualWidth = transposeButton.getBoundsInParent().getWidth();
            if (buttonActualWidth == 0) buttonActualWidth = transposeButton.getPrefWidth();
            double targetX = (containerWidth / 2.0) - (buttonActualWidth / 2.0);
            
            if (Math.abs(transposeButton.getTranslateX() - targetX) > 0.1) {
                transposeButtonAnimator.setOnFinished(null);
                transposeButtonAnimator.setToX(targetX);
                transposeButtonAnimator.play();
            } else {
                 transposeButton.setTranslateX(targetX);
            }
            buttonsContainer.requestLayout();
            transposeButton.requestLayout();
        }
    }

    @FXML
    private void handleTransposeAction() {
        System.out.println("Transpose button clicked");
        try {
            double[][] inputData = getMatrixFromInput();
            if (inputData == null) return;
            Matrix matrix = new Matrix(inputData);
            Matrix transposedMatrix = matrix.transpose();
            displayMatrixResult(transposedMatrix.getData(), "Транспонированная матрица:"); 
        } catch (IllegalArgumentException e) {
            showErrorInResultArea("Ошибка создания матрицы: " + e.getMessage());
        } catch (Exception e) {
            showErrorInResultArea("Произошла ошибка при транспонировании: " + e.getMessage());
            e.printStackTrace();
        }
    }

    @FXML
    private void handleInverseAction() {
        System.out.println("Inverse button clicked");
        try {
            double[][] inputData = getMatrixFromInput();
            if (inputData == null) return;
            if (rowsSpinner.getValue() != colsSpinner.getValue()) {
                showErrorInResultArea("Ошибка: Матрица должна быть квадратной для обращения.");
                return;
            }
            Matrix matrix = new Matrix(inputData);
            Matrix invertedMatrix = matrix.inverse();
            displayMatrixResult(invertedMatrix.getData(), "Обратная матрица:");
        } catch (IllegalArgumentException e) {
            showErrorInResultArea("Ошибка создания матрицы: " + e.getMessage());
        } catch (MatrixOperationException e) {
            showErrorInResultArea("Ошибка обращения матрицы: " + e.getMessage());
        } catch (Exception e) {
            showErrorInResultArea("Произошла ошибка при обращении: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private double[][] getMatrixFromInput() {
        int currentRows = rowsSpinner.getValue();
        int currentCols = colsSpinner.getValue();
        double[][] matrix = new double[currentRows][currentCols];

        if (matrixTextFields == null || matrixTextFields.size() != currentRows) {
             showErrorInResultArea("Ошибка: Несоответствие данных для ввода матрицы. Пожалуйста, обновите размер.");
             return null;
        }

        for (int i = 0; i < currentRows; i++) {
            if (matrixTextFields.get(i) == null || matrixTextFields.get(i).size() != currentCols) {
                showErrorInResultArea("Ошибка: Несоответствие данных для ввода матрицы (строка " + (i+1) + "). Пожалуйста, обновите размер.");
                return null;
            }
            for (int j = 0; j < currentCols; j++) {
                TextField textField = matrixTextFields.get(i).get(j);
                String text = textField.getText().trim();
                if (text.isEmpty() || text.equals("-") || text.equals(".")) {
                    matrix[i][j] = 0.0;
                } else {
                    try {
                        matrix[i][j] = Double.parseDouble(text);
                    } catch (NumberFormatException e) {
                        showErrorInResultArea("Ошибка: Некорректное значение в ячейке ввода [" + (i + 1) + "," + (j + 1) + "]: '" + textField.getText() + "'");
                        textField.requestFocus();
                        textField.selectAll();
                        return null;
                    }
                }
            }
        }
        return matrix;
    }

    private void displayMatrixResult(double[][] matrixData, String title) {
        if (resultMatrixGrid == null) return;
        resultMatrixGrid.getChildren().clear();

        if (matrixData == null || matrixData.length == 0 || (matrixData.length > 0 && matrixData[0].length == 0) ) {
            Label emptyMsg = new Label(title + ( (matrixData != null && matrixData.length > 0 && matrixData[0].length == 0) ? ": результат - матрица 0 столбцов." : ": результат - пустая матрица." ));
            emptyMsg.getStyleClass().add("info-label");
            resultMatrixGrid.add(emptyMsg, 0, 0);
            GridPane.setColumnSpan(emptyMsg, Math.max(1, colsSpinner.getValue()));
            GridPane.setHalignment(emptyMsg, Pos.CENTER);
            return;
        }

        int resultRows = matrixData.length;
        int resultCols = matrixData[0].length;

        for (int i = 0; i < resultRows; i++) {
            for (int j = 0; j < resultCols; j++) {
                TextField resultField = new TextField();
                resultField.setText(String.format("%.3f", matrixData[i][j]));
                resultField.setEditable(false);
                resultField.setFocusTraversable(false);
                resultField.getStyleClass().add("result-matrix-cell");
                resultField.setPrefWidth(60); 
                resultField.setPrefHeight(35);
                resultField.setAlignment(Pos.CENTER);
                resultMatrixGrid.add(resultField, j, i);
            }
        }
    }

    private void showErrorInResultArea(String errorMessage) {
        if (resultMatrixGrid == null) return;
        resultMatrixGrid.getChildren().clear();
        Label errorLabel = new Label(errorMessage);
        errorLabel.getStyleClass().add("error-label");
        errorLabel.setWrapText(true);
        resultMatrixGrid.add(errorLabel, 0, 0); 
        int colspan = Math.max(1, colsSpinner.getValue());
        GridPane.setColumnSpan(errorLabel, colspan);
        GridPane.setHalignment(errorLabel, Pos.CENTER);
    }
}


--- File: src/main/java/com/azapps/matrixapp/MainApp.java ---
package com.azapps.matrixapp;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.io.IOException;
import java.net.URL;
import java.util.Objects;

public class MainApp extends Application {

    @Override
    public void start(Stage primaryStage) {
        try {
            // Загружаем FXML файл из папки resources/com/azapps/matrixapp/view/
            // Обратите внимание на путь к FXML файлу.
            // getClass().getResource() ищет ресурс относительно расположения класса MainApp.
            // "/com/azapps/matrixapp/view/MainView.fxml" - абсолютный путь от корня classpath.
            // Если FXML лежит в той же папке, что и MainApp (или в подпапке view относительно MainApp),
            // можно использовать относительный путь: "view/MainView.fxml"
            URL fxmlLocation = getClass().getResource("/com/azapps/matrixapp/view/MainView.fxml");
            if (fxmlLocation == null) {
                System.err.println("Не удалось найти FXML файл. Проверьте путь: /com/azapps/matrixapp/view/MainView.fxml");
                // Можно выбросить исключение или показать диалоговое окно с ошибкой
                return;
            }
            Parent root = FXMLLoader.load(Objects.requireNonNull(fxmlLocation));

            // Устанавливаем заголовок окна
            primaryStage.setTitle("Калькулятор Матриц");

            // Создаем сцену
            Scene scene = new Scene(root, 800, 600); // Начальные размеры окна

            // Устанавливаем сцену для Stage
            primaryStage.setScene(scene);

            // Отображаем Stage (окно)
            primaryStage.show();

        } catch (IOException e) {
            // Обработка исключения, если FXML файл не может быть загружен
            e.printStackTrace();
            // Здесь можно показать пользователю сообщение об ошибке
            // например, через Alert
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}


--- File: src/main/java/module-info.java ---
module com.azapps.matrixapp {
    // Зависимости от модулей JavaFX
    requires javafx.controls;
    requires javafx.fxml;
    requires javafx.graphics; // Явно добавим зависимость от javafx.graphics, так как он упоминается в ошибке

    // Открываем наши пакеты для JavaFX FXML
    opens com.azapps.matrixapp to javafx.fxml;
    opens com.azapps.matrixapp.controller to javafx.fxml;
    // Если FXML будет напрямую ссылаться на классы модели,
    // то и пакет модели нужно будет открыть:
    // opens com.azapps.matrixapp.model to javafx.fxml;

    // ЭКСПОРТИРУЕМ пакет, содержащий MainApp
    exports com.azapps.matrixapp; // Эта строка необходима
    // Если другие модули (кроме javafx.graphics) должны использовать ваши контроллеры или модели,
    // их тоже можно экспортировать, но для текущей ошибки важен именно пакет с MainApp.
    // exports com.azapps.matrixapp.controller;
    // exports com.azapps.matrixapp.model;
}


--- File: src/main/resources/com/azapps/matrixapp/view/MainView.fxml ---
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.control.Spinner?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.Priority?>
<?import javafx.scene.layout.Region?>
<?import javafx.scene.layout.VBox?>

<BorderPane xmlns="http://javafx.com/javafx/21"
            xmlns:fx="http://javafx.com/fxml/1"
            fx:controller="com.azapps.matrixapp.controller.MainViewController"
            prefHeight="700.0" prefWidth="900.0"
            stylesheets="@../css/styles.css"> <!-- Подключаем CSS файл -->

    <top>
        <VBox alignment="CENTER" spacing="10" styleClass="header-box"> <!-- Используем styleClass -->
            <Label text="Калькулятор Матриц" styleClass="header-label"/> <!-- Используем styleClass -->
        </VBox>
    </top>

    <center>
        <VBox spacing="15" alignment="TOP_CENTER">
            <padding>
                <Insets top="20" right="20" bottom="20" left="20"/>
            </padding>

            <Label text="Введите элементы матрицы:" styleClass="section-label"/>

            <ScrollPane fx:id="matrixScrollPane" fitToWidth="true" fitToHeight="true" VBox.vgrow="ALWAYS"
                        minHeight="200" prefHeight="300">
                <content>
                    <GridPane fx:id="matrixInputGrid" hgap="5" vgap="5" alignment="CENTER">
                        <padding>
                            <Insets top="10" right="10" bottom="10" left="10"/>
                        </padding>
                    </GridPane>
                </content>
            </ScrollPane>

            <!-- Панель управления: размеры и кнопки -->
            <HBox spacing="20" alignment="CENTER_LEFT">
                <padding>
                    <Insets top="10"/>
                </padding>

                <!-- Секция задания размера (фиксированная ширина) -->
                <HBox fx:id="sizeControlBox" spacing="5" alignment="CENTER_LEFT" prefWidth="250" minWidth="250" maxWidth="250">
                    <Label text="Размер матрицы:" styleClass="control-label"/>
                    <Spinner fx:id="rowsSpinner" editable="true" min="1" max="10" initialValue="2" prefWidth="70"/>
                    <Label text="x" styleClass="control-label-small"/>
                    <Spinner fx:id="colsSpinner" editable="true" min="1" max="10" initialValue="2" prefWidth="70"/>
                </HBox>

                <!-- Распорка, чтобы кнопки были справа -->
                <Region HBox.hgrow="ALWAYS"/>

                <!-- Контейнер для кнопок (фиксированная ширина справа) -->
                <HBox fx:id="buttonsContainer" spacing="10" alignment="CENTER_RIGHT"
                      prefWidth="350" minWidth="350" maxWidth="350">
                    <!-- Кнопки будут иметь одинаковую предпочтительную ширину и расти, если нужно -->
                    <Button fx:id="transposeButton" text="Транспонировать" onAction="#handleTransposeAction"
                            prefHeight="40" styleClass="action-button"/>
                    <Button fx:id="inverseButton" text="Обратить" onAction="#handleInverseAction"
                            prefHeight="40" styleClass="action-button"/>
                </HBox>
            </HBox>

            <Label text="Результат:" styleClass="section-label" style="-fx-padding: 10 0 0 0;"/>
            <ScrollPane fx:id="resultMatrixScrollPane" fitToWidth="true" fitToHeight="true" VBox.vgrow="ALWAYS"
                        minHeight="100" prefHeight="200" styleClass="scroll-pane"> <!-- Добавим стиль, если нужно -->
                <content>
                    <GridPane fx:id="resultMatrixGrid" hgap="5" vgap="5" alignment="CENTER">
                        <padding>
                            <Insets top="10" right="10" bottom="10" left="10"/>
                        </padding>
                        <!-- Ячейки для вывода результата будут добавляться сюда программно -->
                    </GridPane>
                </content>
            </ScrollPane>

        </VBox>
    </center>
</BorderPane>


--- File: src/main/resources/com/azapps/matrixapp/css/styles.css ---
/* styles.css */

.root {
    -fx-font-family: "System"; /* Или другой предпочитаемый шрифт */
    -fx-font-size: 14px;
}

.header-box {
    -fx-background-color: #4A90E2; /* Приятный синий цвет */
    -fx-padding: 15px;
}

.header-label {
    -fx-font-size: 24px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.section-label {
    -fx-font-size: 16px;
    -fx-font-weight: bold;
    -fx-text-fill: #333333;
}

.control-label {
    -fx-font-size: 14px;
    -fx-text-fill: #444444;
}
.control-label-small {
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-text-fill: #444444;
}

.spinner .arrow-button {
    -fx-padding: 2 5 2 5; /* Уменьшаем отступы кнопок спиннера */
}

.spinner .text-field {
     -fx-pref-height: 30px; /* Высота текстового поля спиннера */
}


.action-button {
    -fx-background-color: #5CB85C; /* Зеленый */
    -fx-text-fill: white;
    -fx-font-weight: bold;
    -fx-font-size: 14px;
    -fx-background-radius: 5px; /* Скругленные углы */
    -fx-padding: 10px 15px; /* Отступы внутри кнопки */
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.1), 5, 0, 2, 2); /* Легкая тень */
}

.action-button:hover {
    -fx-background-color: #4CAF50; /* Темнее при наведении */
}

.action-button:pressed {
    -fx-background-color: #45A049; /* Еще темнее при нажатии */
}

/* Можно добавить стиль для кнопки "Обратить", если хотите другой цвет */
#inverseButton.action-button { /* ID selector для специфичной кнопки */
    -fx-background-color: #F0AD4E; /* Оранжевый */
}
#inverseButton.action-button:hover {
    -fx-background-color: #EEA236;
}
#inverseButton.action-button:pressed {
    -fx-background-color: #EC9B2F;
}


.text-field { /* Стиль для обычных текстовых полей в гриде */
    -fx-pref-height: 35px;
    -fx-border-color: #cccccc;
    -fx-border-radius: 3px;
}

.text-field:focused {
    -fx-border-color: #4A90E2;
    -fx-effect: dropshadow(gaussian, #4A90E2, 5, 0.1, 0, 0);
}


.result-text {
    -fx-font-family: "Courier New", monospace;
    -fx-font-size: 14px;
    -fx-fill: #333333;
    -fx-background-color: #f9f9f9;
    -fx-border-color: #e0e0e0;
    -fx-padding: 10px;
}

.scroll-pane {
    -fx-background-color: transparent; /* Чтобы не было двойных рамок */
}

.scroll-pane .viewport {
    -fx-background-color: transparent;
}

.result-matrix-cell {
    -fx-background-color: #f0f0f0; /* Слегка серый фон для нередактируемых полей */
    -fx-border-color: #d0d0d0;
    -fx-border-radius: 3px;
    /* Можно убрать эффект фокуса, так как они нередактируемы */
    -fx-focus-color: transparent;
    -fx-faint-focus-color: transparent;
}

.error-label {
    -fx-text-fill: red;
    -fx-font-style: italic;
    -fx-padding: 10px;
}


